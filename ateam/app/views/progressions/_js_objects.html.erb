<!--  <script>


    /*********************************************************************************************************************************/
    /**************************************************** <DRAWING OBJECTS> **********************************************************/
    /*********************************************************************************************************************************/

    fabric.Basket = fabric.util.createClass(fabric.Circle, {
        type: 'Basket',
        initialize(options) {
            options || (options = { });
            this.callSuper('initialize', options);
            this.set({
              hasControls: false,
              selectable: false,
              hasBorders: false,
              evented: false,
              perPixelTargetFind: true,
              fill: "transparent"
            });
        },

        _render(ctx) {
            this.callSuper('_render', ctx);
        }, 

        toObject() {
            return fabric.util.object.extend(this.callSuper('toObject'), {
              customProps: this.customProps,
              color: this.color,
              hasControls: this.hasControls,
              selectable: this.selectable,
              hasBorders: this.hasBorders,
              evented: this.evented,
              perPixelTargetFind: this.perPixelTargetFind,
              id: this.id,
            });
        },

    });

    function plotBasket(basket_left, basket_top, r, canvas_width, canvas){
      var basket = new fabric.Basket({
        left: basket_left - r,
        top: basket_top,
        strokeWidth: 2,
        radius: r,
        stroke: "black",
        canvas_width: canvas_width,
      });
      canvas.add(basket);
      return basket;
    }

    fabric.Basket.fromObject = function(object, callback) {
        return fabric.Object._fromObject('Basket', object, callback);
    };


    /**************************************************** <CURVED LINE> **************************************************************/
    fabric.MoveLine = fabric.util.createClass(fabric.Path, {
      type: "MoveLine",
      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          selectable: false,
          hasBorders: false,
          evented: false,
          perPixelTargetFind: true,
          anchorable: true,
        });
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
         const xDiff = this.path[1][3] - this.path[0][1];
         const yDiff = this.path[1][4] - this.path[0][2];
         const angle = Math.atan2(yDiff, xDiff);
         this.anchorAngle = angle;
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          id: this.id,
          customProps: this.customProps,
          anchorAngle: this.anchorAngle,
          color: this.color,
          toAnchorPoint: this.toAnchorPoint,
          anchorable: this.anchorable,
          anchorId: this.anchorId,
          toAnchorId: this.toAnchorId,
          hasControls: this.hasControls,
          selectable: this.selectable,
          hasBorders: this.hasBorders,
          evented: this.evented,
          perPixelTargetFind: this.perPixelTargetFind,
          padding: this.padding,
          objectCaching: this.objectCaching,
          path: this.path,
          isMoveLine: this.isMoveLine,
          moveLineId: this.moveLineId,
          passLineId: this.passLineId,
          passerId: this.passerId,
          lineEndId: this.lineEnd.id,
          // height: this.height,
          // width: this.width,
          // pathOffset: this.pathOffset,
          // prevDims: this.prevDims,
        });

      },


    });

     fabric.MoveLine.fromObject = function(object, callback) {
       callback && callback(new fabric.MoveLine(getPathString(object.path), object));
     };

    /**************************************************** <CURVED LINE/> *************************************************************/

    /**************************************************** <LINE WITH ARROW> **********************************************************/

    //   fabric.LineWithArrow = fabric.util.createClass(fabric.Line, {
    //   type: 'LineWithArrow',

    //   initialize(element, options) {
    //     console.log("initializing")
    //     options || (options = {});
    //     this.callSuper('initialize', element, options);

    //     // Set default options
    //     this.set({
    //       id:   this.id,
    //       hasControls: false,
    //       selectable: true,
    //       hasBorders: false,
    //       evented: true,
    //       perPixelTargetFind: true,
    //       anchorable: true,
    //     });
    //   },

    //   _render(ctx) {
    //     this.callSuper('_render', ctx);
    //     ctx.save();
    //     const xDiff = this.x2 - this.x1;
    //     const yDiff = this.y2 - this.y1;
    //     const angle = Math.atan2(yDiff, xDiff);
    //     ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
    //     ctx.rotate(angle);
    //     this.anchorAngle = angle;
    //     ctx.beginPath();
    //     // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
    //     ctx.moveTo(5, 0);
    //     ctx.lineTo(-5, 5);
    //     ctx.lineTo(-5, -5);
    //     ctx.closePath();
    //     ctx.fillStyle = this.stroke;
    //     ctx.fill();
    //     ctx.restore();
    //   },

    //   toObject() {
    //     return fabric.util.object.extend(this.callSuper('toObject'), {
    //       id: this.id,
    //       customProps: this.customProps,
    //       anchorAngle: this.anchorAngle,
    //       color: this.color,
    //       toAnchorPoint: this.toAnchorPoint,
    //       anchorable: this.anchorable,
    //       anchorId: this.anchorId,
    //       toAnchorId: this.toAnchorId,
    //       hasControls: this.hasControls,
    //       selectable: this.selectable,
    //       hasBorders: this.hasBorders,
    //       evented: this.evented,
    //       perPixelTargetFind: this.perPixelTargetFind,
    //       padding: this.padding,
    //       objectCaching: this.objectCaching,
    //       x1: this.x1,
    //       x2: this.x2,
    //       y1: this.y1,
    //       y2: this.y2,
    //       isMoveLine: this.isMoveLine,
    //       moveLineId: this.moveLineId,
    //       passLineId: this.passLineId,
    //       passerId: this.passerId,
    //     });

    //   },


    // });

    // fabric.LineWithArrow.fromObject = function(object, callback) {
    //   callback && callback(new fabric.LineWithArrow([object.x1, object.y1, object.x2, object.y2], object));
    // };




    /********************************************************* <LINE WITH ARROW/> *****************************************************/






    /************************************************************ <PASS LINE> *********************************************************/

    fabric.PassLine = fabric.util.createClass(fabric.Line, {
      type: 'PassLine',
      strokeDashArray: [5, 5],

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          selectable: true,
          hasBorders: false,
          evented: true,
          perPixelTargetFind: true,
        });
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
        ctx.save();
        const xDiff = this.x2 - this.x1;
        const yDiff = this.y2 - this.y1;
        const angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        this.anchorAngle = angle;
        ctx.beginPath();
        // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(5, 0);
        ctx.lineTo(-5, 5);
        ctx.lineTo(-5, -5);
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();
        ctx.restore();
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          id: this.id,
          customProps: this.customProps,
          color: this.color,
          toAnchorPoint: this.toAnchorPoint,
          anchorAngle: this.anchorAngle,
          anchorable: this.anchorable,
          anchorId: this.anchorId,
          toAnchorId: this.toAnchorId,
          hasControls: this.hasControls,
          selectable: this.selectable,
          hasBorders: this.hasBorders,
          evented: this.evented,
          perPixelTargetFind: this.perPixelTargetFind,
          padding: this.padding,
          objectCaching: this.objectCaching,
          x1: this.x1,
          x2: this.x2,
          y1: this.y1,
          y2: this.y2,
          isMoveLine: this.isMoveLine,
          moveLineId: this.moveLineId,
          passLineId: this.passLineId,
        });
      },
    });

    fabric.PassLine.fromObject = function(object, callback) {
      callback && callback(new fabric.PassLine([object.x1, object.y1, object.x2, object.y2], object));
    };

    /************************************************************ <PASS LINE/> ********************************************************/






    /************************************************************ <SCREEN LINE> *******************************************************/

    fabric.ScreenLine = fabric.util.createClass(fabric.Line, {
      type: 'ScreenLine',

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          evented: true,
          perPixelTargetFind: true,
        });
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
        ctx.save();
        const xDiff = this.x2 - this.x1;
        const yDiff = this.y2 - this.y1;
        const angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        this.anchorAngle = angle;
        ctx.beginPath();
        // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(0, -10);
        ctx.lineTo(0, 10);
        ctx.stroke()
        ctx.closePath();
        ctx.strokeStyle = this.stroke;
        //ctx.fill();
        ctx.restore();
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          id: this.id,
          customProps: this.customProps,
          color: this.color,
          toAnchorPoint: this.toAnchorPoint,
          anchorAngle: this.anchorAngle,
          anchorable: this.anchorable,
          anchorId: this.anchorId,
          toAnchorId: this.toAnchorId,
          hasControls: this.hasControls,
          selectable: this.selectable,
          hasBorders: this.hasBorders,
          evented: this.evented,
          perPixelTargetFind: this.perPixelTargetFind,
          padding: this.padding,
          objectCaching: this.objectCaching,
          x1: this.x1,
          x2: this.x2,
          y1: this.y1,
          y2: this.y2,
          isMoveLine: this.isMoveLine,
          moveLineId: this.moveLineId,
          passLineId: this.passLineId,
          passerId: this.passerId,
        });
      },
    });

    fabric.ScreenLine.fromObject = function(object, callback) {
      callback && callback(new fabric.ScreenLine([object.x1, object.y1, object.x2, object.y2], object));
    };

    /************************************************************ <SCREEN LINE/> ******************************************************/







    /************************************************************ <DRIBBLE LINE> ******************************************************/

    // fabric.DribbleLine = fabric.util.createClass(fabric.Line, {
    //   type: 'DribbleLine',

    //   initialize(element, options) {
    //     options || (options = {});
    //     this.callSuper('initialize', element, options);

    //     // Set default options
    //     this.set({
    //       id:   this.id,
    //       hasControls: false,
    //       hasBorders: false,
    //       selectable: true,
    //       evented: true,
    //       perPixelTargetFind: true,
    //     });
    //   },

    //   _render(ctx) {
    //     //this.callSuper('_render', ctx);
    //     ctx.save();
    //   const xDiff = this.x2 - this.x1;
    //   const yDiff = this.y2 - this.y1;
    //   const angle = Math.atan2(yDiff, xDiff);
    //   ctx.translate(xDiff / 2, yDiff / 2);
    //   ctx.rotate(angle);
    //   this.anchorAngle = angle;
    //   ctx.beginPath();
    //   // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
    //   ctx.moveTo(3, 0);
    //   ctx.lineTo(-3, 3);
    //   ctx.lineTo(-3, -3);
    //   ctx.closePath();
    //   ctx.fillStyle = this.stroke;
    //   ctx.fill();
    //   ctx.restore();
    //   var p = this.calcLinePoints();
    //   var point = this.pointOnLine(this.point(p.x2, p.y2), this.point(p.x1, p.y1), 10)
    //   this.wavy(this.point(p.x1, p.y1), point, this.point(p.x2, p.y2), ctx);
    //   ctx.stroke();
    //   },


    //   point: function(x, y) {
    //       return {
    //         x: x,
    //         y: y
    //       };
    //   },

    //   wavy: function(from, to, endPoint, ctx) {
    //       var cx = 0,
    //         cy = 0,
    //         fx = from.x,
    //         fy = from.y,
    //         tx = to.x,
    //         ty = to.y,
    //         i = 0,
    //         step = 2,
    //         waveOffsetLength = 0,

    //         ang = Math.atan2(ty - fy, tx - fx),
    //         distance = Math.sqrt((fx - tx) * (fx - tx) + (fy - ty) * (fy - ty)),
    //         amplitude = -10
    //         f = distance / 4;

    //       for (i; i <= distance; i += step) {
    //         waveOffsetLength = triangle_line((i / distance) * f);
    //         cx = from.x + Math.cos(ang) * i + Math.cos(ang - Math.PI / 2) * waveOffsetLength;
    //         cy = from.y + Math.sin(ang) * i + Math.sin(ang - Math.PI / 2) * waveOffsetLength;
    //         i > 0 ? ctx.lineTo(cx, cy) : ctx.moveTo(cx, cy);
    //       }
    //       ctx.lineTo(to.x, to.y);
    //       ctx.lineTo(endPoint.x, endPoint.y);
    // },

    // pointOnLine: function(point1, point2, dist) {
    //   var len = Math.sqrt(((point2.x - point1.x) * (point2.x - point1.x)) + ((point2.y - point1.y) * (point2.y - point1.y)));
    //   var t = (dist) / len;
    //   var x3 = ((1 - t) * point1.x) + (t * point2.x),
    //     y3 = ((1 - t) * point1.y) + (t * point2.y);
    //   return new fabric.Point(x3, y3);
    // },

    //   toObject() {
    //     return fabric.util.object.extend(this.callSuper('toObject'), {
    //       id: this.id,
    //       customProps: this.customProps,
    //       color: this.color,
    //       toAnchorPoint: this.toAnchorPoint,
    //       anchorAngle: this.anchorAngle,
    //       anchorable: this.anchorable,
    //       anchorId: this.anchorId,
    //       toAnchorId: this.toAnchorId,
    //       hasControls: this.hasControls,
    //       selectable: this.selectable,
    //       hasBorders: this.hasBorders,
    //       evented: this.evented,
    //       perPixelTargetFind: this.perPixelTargetFind,
    //       padding: this.padding,
    //       objectCaching: this.objectCaching,
    //       x1: this.x1,
    //       x2: this.x2,
    //       y1: this.y1,
    //       y2: this.y2,
    //       isMoveLine: this.isMoveLine,
    //       moveLineId: this.moveLineId,
    //       passLineId: this.passLineId,
    //       passerId: this.passerId,
    //     });
    //   },
    // });

    // fabric.DribbleLine.fromObject = function(object, callback) {
    //   callback && callback(new fabric.DribbleLine([object.x1, object.y1, object.x2, object.y2], object));
    // };


    /************************************************************ <DRIBBLE LINE/> *****************************************************/






    /********************************************************** <DRAWING FUNCTIONS> ***************************************************/
    function textBox(button){
      selection()
      highlight_play_button(button)
      canvas.on('mouse:down', function(e){
        
        var pointer = canvas.getPointer(e.e);
        var text = new fabric.Textbox('Text', {
            width: 150,
            height: 200,
            top: pointer.y,
            left: pointer.x,
            hasControls: true,
            fontSize: 18,
            fixedFontSize: 18,
            fixedWidth: 150
        });
        canvas.add(text);
        deselectDrawingButton()
        selection()
      })
    }

    function triangle_line(x){
      let g = x % 6;
      if(g<=3) return g*5;
      if(g>3) return (6-g)*5;
    }

    function selection() {
      changeObjSelection(true);
      canvas.off('mouse:down');
      canvas.off('mouse:move');
      canvas.off('mouse:up');
      evented = false;
      canvas.selection = false;
    }

    function drawCurve(anchor, line_type){
      selection()
      var line;
      changeObjSelection(false);
      if (!evented) {
        canvas.on('mouse:down', function(e){
            line = curveMouseDown(anchor, line_type, e)});
        canvas.on('mouse:move', function(e){
            line = curveMouseMove(anchor,line_type, line, e)});
        canvas.on('mouse:up', function(e){
            line = curveMouseUp(anchor,line_type, line, e);
            if(line){
              line.anchorId = anchor.id;
              line.moveTo(9)
              if(line.isMoveLine){
                anchor.moveLineId = line.id;
                anchor.moveLine = line;
                insertEndpoint(line)
              }
              else{
                anchor.passLineId = line.id;
                anchor.passLine = line;
              }
            }
            else{
              canvas.setActiveObject(anchor);
              drawCurve(anchor, line_type)
            }
        });
        evented = true;
      }
    }

    function centerOfSlopeLine(x1, y1, x2, y2){
      var centerX = (x1+x2)/2;
      var centerY = (y1+y2)/2;
      return new fabric.Point(centerX, centerY);
    }

    function curveMouseDown(anchor, line_type, options){
      isDown = true;
      var pointer = canvas.getPointer(options.e);
      var anchor_point = anchor.toAnchorPoint;
      var slope_line_center = centerOfSlopeLine(anchor_point.x, anchor_point.y, pointer.x, pointer.y);

      var points = [[anchor_point.x, anchor_point.y], [slope_line_center.x, slope_line_center.y, pointer.x, pointer.y]]
      
      var line = selectLine(points, anchor.color, line_type);
      line.color = anchor.color;
      canvas.add(line);
      line.moveTo(9)
      return line;
    }

    // TODO: need new function that is updateEndpointPosition
    function updateTrianglePosition(line, angle){
      var lineEnd = line.lineEnd;
      var offset = 1;
      if(line.kind == "Dribble"){
        offset = 1.5
      }
      lineEnd.set({left: line.path[1][3]+offset, top: line.path[1][4]+offset, angle: radians_to_degrees(angle) + 90})
      lineEnd.setCoords()
    }

    function updateScreenPosition(line, angle){
      var lineEnd = line.lineEnd;
      lineEnd.set({x1: line.path[1][3] + Math.cos(angle - Math.PI/2) * 10, y1: line.path[1][4] + Math.sin(angle - Math.PI/2) *10, x2:  line.path[1][3] + Math.cos(angle + Math.PI/2) * 10, y2: line.path[1][4] + Math.sin(angle + Math.PI/2) *10})

      lineEnd.setCoords()
    }


    function updateEndpointPosition(line, angle){
      if(line.lineEnd.type == "line"){
        updateScreenPosition(line, angle)
      }
      else{
        updateTrianglePosition(line, angle)
      }
    }

    function curveMouseMove(anchor, line_type, line, options){
      if (!isDown) return;
      var pointer = canvas.getPointer(options.e);
      var slope_line_center = centerOfSlopeLine(line.path[0][1], line.path[0][2], pointer.x, pointer.y);
      line.path[1][1] = slope_line_center.x;
      line.path[1][2] = slope_line_center.y;
      line.path[1][3] = pointer.x;
      line.path[1][4] = pointer.y;

      var anchorAngle = getAnchorAngle(line.path[0][1], line.path[1][3], line.path[0][2], line.path[1][4])
      updateEndpointPosition(line, anchorAngle)
      canvas.requestRenderAll();

      return line;
    }

    function insideAnchorRadius(anchor, pointer){
      var centerX = anchor.left + anchor.radius;
      var centerY = anchor.top + anchor.radius;
      if(Math.sqrt((pointer.x-centerX)*(pointer.x-centerX) + (pointer.y-centerY)*(pointer.y-centerY))<anchor.radius){
        return true
      }
      return false;
    }
    

    function curveMouseUp(anchor, line_type, line, options){
      isDown = false;

      var pointer = canvas.getPointer(options.e);
      // pointer is inside of the radius of the anchor
      if(insideAnchorRadius(anchor, pointer)){
        canvas.remove(line.lineEnd)
        canvas.remove(line)
        return false
      }
      else{
        var slope_line_center = centerOfSlopeLine(line.path[0][1], line.path[0][2], pointer.x, pointer.y);
        line.path[1][1] = slope_line_center.x;
        line.path[1][2] = slope_line_center.y;
        line.path[1][3] = pointer.x;
        line.path[1][4] = pointer.y;
        var anchorAngle = getAnchorAngle(line.path[0][1], line.path[1][3], line.path[0][2], line.path[1][4])
        // TODO: change to update endpoint position
        updateEndpointPosition(line, anchorAngle)
        var success = true;
    
        var centerX = line.path[1][3] - anchorOffset + (Math.cos(line.anchorAngle) * 10);
        var centerY = line.path[1][4] - anchorOffset + (Math.sin(line.anchorAngle) * 10);
        /*INVESTIGATE WHY I WANTED TO CHANGE -- LOOKS GOOD*/
        line.toAnchorPoint = new fabric.Point(centerX + anchorOffset, centerY + anchorOffset);

        line.id = anchor.id + "_moveline_"

        /*CHANGE*/
        var toAnchor = new fabric.ToAnchor({
          kind: "toAnchor",
          id: line.id + "_toAnchor",
          selectable: true,
          evented: true,
          hasControls: false,
          hasBorders: false,
          left: centerX,
          top: centerY,
          line: line,
          anchorAngle: anchorAngle,
          // lockMovementY: true,
          // lockMovementX: true,
          radius: anchorRadius,
          strokeWidth: 1,
          stroke: line.stroke,
          fill: "white",
          added: true,
          padding: 20,
        });
        var curvePoint = new fabric.CurvePoint({
          kind: "curvePoint",
          id: line.id + "_curvePoint",
          selectable: true,
          evented: true,
          hasControls: false,
          hasBorders: false,
          left: slope_line_center.x,
          top: slope_line_center.y,
          line: line,
          radius: anchorRadius,
          fill: "#7ceb3b",
          stroke: "black",
          strokeWidth: 1,
          added: true,
          padding: 10,
        });

        line.lineEnd.id = line.id + "_lineEnd"
        line.anchorable = true;
        canvas.add(toAnchor);
        canvas.add(curvePoint)
        line.toAnchorId = toAnchor.id;
        line.toAnchor = toAnchor;
        line.curvePoint = curvePoint;
        line.curvePointId = curvePoint.id
        
        toAnchor.moveTo(10)
        line.moveTo(3);
        
        canvas.requestRenderAll();
        selection();
        // Reconsider this
        canvas.setActiveObject(line);
        deselectDrawingButton()
      }

      
      return line;
    }

    function getPathString(path){
      return 'M'+path[0][1] +','+ path[0][2] + ' Q' + path[1][1] + ',' + path[1][2] + ' ' + path[1][3] + ',' + path[1][4] 
    }


    function drawMoveLine(points, color){
      var path_string = 'M'+points[0][0] +','+ points[0][1] + ' Q' + points[1][0] + ',' + points[1][1] + ' ' + points[1][2] + ',' + points[1][3] 
      var line = new fabric.MoveLine(path_string, {
         fill: '',
         strokeWidth: 2,
         stroke: color,
         objectCaching: false,
         isMoveLine: true,
         padding: 10,
         lockMovementY: true,
         lockMovementX: true,
         kind: "SimpleMove",
       });
      
      line.path[0][1] = points[0][0];
      line.path[0][2] = points[0][1];

      line.path[1][1] = points[1][0];
      line.path[1][2] = points[1][1];

      line.path[1][3] = points[1][2];
      line.path[1][4] = points[1][3];

      var anchorAngle = getAnchorAngle(line.path[0][1], line.path[1][3], line.path[0][2], line.path[1][4])
      var lineEnd = createTriangle(points[1][2] +1, points[1][3] + 1, anchorAngle, color, 12)
      line.lineEnd = lineEnd;
      canvas.add(lineEnd)
      return line;
    }

    function drawDribbleLine(points, color){
      var path_string = 'M'+points[0][0] +','+ points[0][1] + ' Q' + points[1][0] + ',' + points[1][1] + ' ' + points[1][2] + ',' + points[1][3] 
      var line = new fabric.MoveLine(path_string, {
         fill: '',
         strokeWidth: 4,
         stroke: "#00ab00",
         objectCaching: false,
         isMoveLine: true,
         padding: 10,
         lockMovementY: true,
         lockMovementX: true,
         kind: "Dribble",
       });
      
      line.path[0][1] = points[0][0];
      line.path[0][2] = points[0][1];

      line.path[1][1] = points[1][0];
      line.path[1][2] = points[1][1];

      line.path[1][3] = points[1][2];
      line.path[1][4] = points[1][3];

      var anchorAngle = getAnchorAngle(line.path[0][1], line.path[1][3], line.path[0][2], line.path[1][4])
      var lineEnd = createTriangle(points[1][2]+1, points[1][3] +1, anchorAngle, "#00ab00")
      line.lineEnd = lineEnd;
      canvas.add(lineEnd)
      return line;
    }

    function drawScreenLine(points, color) {
      var path_string = 'M'+points[0][0] +','+ points[0][1] + ' Q' + points[1][0] + ',' + points[1][1] + ' ' + points[1][2] + ',' + points[1][3] 
      var line = new fabric.MoveLine(path_string, {
         fill: '',
         strokeWidth: 2,
         stroke: color,
         objectCaching: false,
         isMoveLine: true,
         padding: 10,
         lockMovementY: true,
         lockMovementX: true,
         kind: "ScreenLine",
       });
      
      line.path[0][1] = points[0][0];
      line.path[0][2] = points[0][1];

      line.path[1][1] = points[1][0];
      line.path[1][2] = points[1][1];

      line.path[1][3] = points[1][2];
      line.path[1][4] = points[1][3];

      var anchorAngle = getAnchorAngle(line.path[0][1], line.path[1][3], line.path[0][2], line.path[1][4])
      var lineEnd = createScreenEnd(points[1][2] +1, points[1][3] + 1, anchorAngle, color)
      line.lineEnd = lineEnd;
      canvas.add(lineEnd)
      return line;
    }

    function createScreenEnd(x, y, angle, color){
      var width = 10;
      var points = [x + Math.cos(angle - Math.PI/2) * 10,  y + Math.sin(angle - Math.PI/2) *10,   x + Math.cos(angle + Math.PI/2) * 10,  y + Math.sin(angle + Math.PI/2) *10]
      var screen_end = new fabric.Line(points,
      { 
          selectable: false,
          strokeWidth: 2,
          evented: false,
          hasBorders: false,
          stroke: color,
          kind: "Screen",

      });
      return screen_end
    }


    function getAnchorAngle(x1, x2, y1, y2){
      var xDiff = x2 - x1;
      var yDiff = y2 - y1;
      var anchorAngle = Math.atan2(yDiff, xDiff);
      return anchorAngle
    }

    function radians_to_degrees(radians){
      var pi = Math.PI;
      return radians * (180/pi);
    }

    function degrees_to_radians(degrees){
      var pi = Math.PI;
      return degrees * pi /180
    }

    function createTriangle(x, y, angle, color, id){
        var width = 12;
        var height = 12;
        return new fabric.Triangle(
        {
            width: width,
            height: height,
            selectable: false,
            evented: false,
            hasBorders: false,
            fill: color,
            left: x,
            top: y,
            originX: 'center',
            originY: 'center',
            angle: radians_to_degrees(angle) + 90,
            kind: "Arrow"
        });
    }


    function draw(anchor, line_type) {
      selection()
      var line;
      changeObjSelection(false);
      if (!evented) {
        canvas.on('mouse:down', function(e){
            line = onMouseDown(anchor, line_type, e)});
        canvas.on('mouse:move', function(e){
            line = onMouseMove(e, line)});
        canvas.on('mouse:up', function(e){
            line = onMouseUp(e, line);
            line.anchorId = anchor.id;
            if(line.isMoveLine){
              anchor.moveLineId = line.id;
              anchor.moveLine = line;
              insertEndpoint(line)
            }
            canvas.setActiveObject(line);
        });
        evented = true;
      }
      return line;
    }


    function changeObjSelection(value) {
      canvas.selection = value;
      canvas.forEachObject(function(obj){
        obj.selectable = value;
      });
      canvas.requestRenderAll();
    }

    function onMouseDown(anchor, line_type, options) {
      isDown = true;
      var pointer = canvas.getPointer(options.e);
      var anchor_point = anchor.toAnchorPoint;
      var points = [anchor_point.x, anchor_point.y, pointer.x, pointer.y]
      
      var line = selectLine(points, anchor.color, line_type);
      line.color = anchor.color;
      if(line.isMoveLine){
        line.id = anchor.id + "_moveline_"
      }
      else {
        line.id = anchor.id + "_passline_"
        anchor.passLineId = line.id;
        anchor.passLine = line;
      }
      canvas.add(line);
      line.moveTo(3);
      return line;

    }

    function onMouseMove(options, line) {
      if (!isDown) return;
      var pointer = canvas.getPointer(options.e);
      line.set({
        x2: pointer.x,
        y2: pointer.y,
      });
      
      canvas.renderAll();
      return line;
    }

    function validatePassReceiver(object){
      var isValidAnchor = false;
      var object_type = object.get("type");
      if (object_type == "PlayerCircle" || object_type == "LineWithArrow" || object_type == "DribbleLine" || object_type == "ScreenLine" || object_type=="MoveLine"){
        isValidAnchor = true;
      }
      return isValidAnchor;
    }

    function findObjectEndpoint(obj){
      return {x: obj.toAnchorPoint.x, y: obj.toAnchorPoint.y}
    }

    // TODO: DUPLICATE CODE
    function removeLineRef(line){
      canvas.getObjects().forEach(function(o){
        if(validateAnchor(o)){
          if(o.passLineId == line.id){
            o.passLineId = null;
            o.passLine = null;
          }
          else if (o.moveLineId == line.id){
            o.moveLineId = null;
            o.moveLine = null
          }
        }
        if(o.passerId == line.id){
          o.passerId = null;
          o.passer = null;
        }
      });
    }


    function findClosestReceiver(line){
      var curr_player = null;
      var min_distance = null;
      var line_distance = Math.sqrt(Math.pow(line.x1-line.x2, 2) + Math.pow(line.y1-line.y2, 2))
      canvas.getObjects().forEach(function(o) {
        if(validatePassReceiver(o) && line.id != o.id){
          var endpoint = findObjectEndpoint(o);
          var dx = Math.pow(endpoint.x - line.x2, 2);
          var dy = Math.pow(endpoint.y - line.y2, 2);
          if(min_distance == null){
            curr_player = o;
            min_distance = dx + dy
          }
          else if (dx + dy < min_distance){
            min_distance = dx + dy
            curr_player = o
          }
        }
      });
      if(line_distance > Math.sqrt(min_distance)){
        return curr_player;
      }
      else{
        return null;
      }
      //return curr_player;
    }


    function snapPassLine(line){
      var receiver = findClosestReceiver(line)
      if(receiver){
        var endpoint = findObjectEndpoint(receiver)
        var pass_line_endpoint = findPassLineEndpoint(line, endpoint, receiver.radius)
        line.set({x2: pass_line_endpoint.x, y2: pass_line_endpoint.y})
        adjustLineAngle(line)
        line.setCoords()
        adjustLineSnap(line, receiver.radius)
        removePassLineRef(line)
        receiver.passer = line;
        receiver.passerId = line.id
        line.setCoords()
        return true;
      }
      else{
        canvas.remove(line.toAnchor);
        canvas.remove(line);
        return false;
      }
    }

    function adjustLineSnap(line, radius){
      if(!radius) radius = 10;
      else radius = radius + 18;
      line.set({x2: line.x2 - Math.cos(line.anchorAngle) * radius, y2: line.y2 - Math.sin(line.anchorAngle) * radius})
    }

    function findPassLineEndpoint(line, endpoint, radius){
      var x = endpoint.x;
      var y = endpoint.y;
      return {x: x, y:y}
    }

    function onMouseUp(options, line) {
      isDown = false;
      line.moveTo(3);
      var success = true;
      
      line.setCoords();
      // if line is created. Not created if passLine isnt close enough to receiver
        var centerX = line.x2 - anchorOffset + Math.cos(line.anchorAngle) * 10;
        var centerY = line.y2 - anchorOffset + Math.sin(line.anchorAngle) * 10;
        
        /*CHANGE*/
        line.toAnchorPoint = new fabric.Point(centerX + anchorOffset, centerY + anchorOffset);

        /*CHANGE*/
        toAnchor = new fabric.ToAnchor({
          id: line.id + "_toAnchor",
          selectable: false,
          evented: false,
          hasControls: false,
          hasBorders: false,
          left: centerX,
          top: centerY,
          lockMovementY: true,
          lockMovementX: true,
          radius: anchorRadius,
          strokeWidth: 1,
          stroke: line.color,
          fill: "white",
          added: true,
        });
        line.anchorable = true;
        canvas.add(toAnchor);
        line.toAnchorId = toAnchor.id;
        line.toAnchor = toAnchor;
        
        line.toAnchor.moveTo(0)

      if(line.type == "PassLine"){
        success = snapPassLine(line)
        adjustLineAngle(line)
        rotateAnchor(line)
      }
      
      
      canvas.requestRenderAll();
      selection();
      deselectDrawingButton()
      return line;
    }




    function drawLineWithArrow(points, color) {
      return new fabric.LineWithArrow(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: false,
        selectable: true,
        padding: 10,
        // lines: [],
        // lineIds: [],
        added: true,
        isMoveLine: true,
        toAnchor: null,
      })
    }

    function drawPassLine(points, color) {
      return new fabric.PassLine(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: true,
        selectable: true,
        padding: 10,
        // lines: [],
        // lineIds: [],
        added: true,
        isMoveLine: false,
        toAnchor: null,
      })
    }

    // function drawDribbleLine(points, color) {
    //   return new fabric.DribbleLine(points, {
    //     strokeWidth: 2,
    //     stroke: color,
    //     objectCaching: false,
    //     selectable: true,
    //     padding: 10,
    //     // lines: [],
    //     // lineIds: [],
    //     added: true,
    //     isMoveLine: true,
    //     toAnchor: null
    //   })
    // }

    function selectLine(points, color, line_type) {
      switch(line_type){
        case "run"  :
            return drawMoveLine(points, color)
        case "screen" :
            return drawScreenLine(points, color);
        case "pass" :
            return drawPassLine(points, color);
        case "dribble" :
            return drawDribbleLine(points, color);
        case "curved":
            return drawCurvedLine(points, color);
      }
      
    }

    /********************************************************** <DRAWING FUNCTIONS/> ***************************************************/
    
    fabric.CurvePoint = fabric.util.createClass(fabric.Circle, {
        type: 'curvePoint',
        initialize(options) {
            options || (options = { });
            this.callSuper('initialize', options);
            this.set({
              id: this.id
            })
        },
        _render(ctx) {
            this.callSuper('_render', ctx);
        }, 

        toObject() {
            return fabric.util.object.extend(this.callSuper('toObject'), {
              customProps: this.customProps,
              id: this.id,
              anchorable: this.anchorable,
              hasControls: this.hasControls,
              selectable: this.selectable,
              hasBorders: this.hasBorders,
              evented: this.evented,
              perPixelTargetFind: this.perPixelTargetFind,
            });
        },

    });

    fabric.CurvePoint.fromObject = function(object, callback) {
        return fabric.Object._fromObject('CurvePoint', object, callback);
    };

    fabric.ToAnchor = fabric.util.createClass(fabric.Circle, {
        type: 'toAnchor',
        initialize(options) {
            options || (options = { });
            this.callSuper('initialize', options);
            this.set({
              id: this.id
            })
        },
        _render(ctx) {
            this.callSuper('_render', ctx);
        }, 

        toObject() {
            return fabric.util.object.extend(this.callSuper('toObject'), {
              customProps: this.customProps,
              id: this.id,
              color: this.color,
              anchorable: this.anchorable,
              hasControls: this.hasControls,
              selectable: this.selectable,
              hasBorders: this.hasBorders,
              evented: this.evented,
              padding: this.padding,
              perPixelTargetFind: this.perPixelTargetFind,
              objectCaching: this.objectCaching
            });
        },

    });

    fabric.ToAnchor.fromObject = function(object, callback) {
        return fabric.Object._fromObject('ToAnchor', object, callback);
    };

    fabric.PlayerCircle = fabric.util.createClass(fabric.Circle, {
        type: 'PlayerCircle',
        initialize(options) {
            options || (options = { });
            this.callSuper('initialize', options);
            this.set({
              id: this.id
            })
        },
        _render(ctx) {
            this.callSuper('_render', ctx);
        }, 

        toObject() {
            return fabric.util.object.extend(this.callSuper('toObject'), {
              customProps: this.customProps,
              id: this.id,
              toAnchorPoint: this.toAnchorPoint,
              color: this.color,
              anchorable: this.anchorable,
              hasControls: this.hasControls,
              selectable: this.selectable,
              hasBorders: this.hasBorders,
              evented: this.evented,
              perPixelTargetFind: this.perPixelTargetFind,
              has_ball: this.has_ball,
              moveLineId: this.moveLineId,
              passLineId: this.passLineId,
              passerId: this.passerId,
              stroke: this.stroke
            });
        },

    });

    fabric.PlayerCircle.fromObject = function(object, callback) {
        return fabric.Object._fromObject('PlayerCircle', object, callback);
    };


    fabric.Basketball = fabric.util.createClass(fabric.Group, {
        type : 'basketball',

        initialize : function(objects, options) {
            options || ( options = { });
            this.callSuper('initialize', objects, options);
        },

        toObject() {
            return fabric.util.object.extend(this.callSuper('toObject'), {
                // insert custom attributes
            });
        },

        _render : function(ctx) {
            this.callSuper('_render', ctx);
        }
    })

    fabric.Basketball.fromObject = function (object, callback) {
        fabric.util.enlivenObjects(object.objects, function (enlivenedObjects) {
            delete object.objects;
            callback && callback(new fabric.Basketball(enlivenedObjects, object));
        });
    };

    /******************************************************** <CIRCLE> ***************************************************************/


    function makeBasketball(top, left, playerRadius){
      var angle = Math.atan((10-0.75)/(70))* 180 / Math.PI
      var start_angle = (angle+90)*(Math.PI/180)
      var end_angle = (270-angle)*(Math.PI/180)

      var c = new fabric.Circle({
        radius: 6,
        stroke: "black",
        strokeWidth: 1,
        fill: 'orange'
      });

      var arc = new fabric.Circle({
        radius: 3.5,
        originX: 'center',
        originY: 'center',
        top: 12,
        left: 6.5,
        angle: 90,
        startAngle: start_angle,
        endAngle: end_angle,
        stroke: 'black',
        strokeWidth: 1,
        fill: '',
        hasControls: false,
        selectable: false,
        hasBorders: false,
        evented: false,
      });

      var line = new fabric.Rect({
        stroke: 'black',
        strokeWidth: 1,
        width: 13,
        top: 6,
        left: -0.5,
        fill: '',
      })

      var arc2 = new fabric.Circle({
        radius: 3.5,
        originX: 'center',
        originY: 'center',
        top: 1,
        left: 6.5 ,
        angle: 270,
        startAngle: start_angle,
        endAngle: end_angle,
        stroke: 'black',
        strokeWidth: 1,
        fill: '',
        perPixelTargetFind: true,
        objectCaching: true,
      });

      var line2 = new fabric.Rect({
        stroke: 'black',
        strokeWidth: 1,
        height: 13,
        top: -0.5,
        left: 6,
        fill: '',
      })



      var g = new fabric.Basketball([c, arc, line, arc2, line2], {
        top: top + 1.7* playerRadius,
        left: left + 1.7* playerRadius,
        hasControls: false,
        hasBorders: false,
        selectable: false,
        evented: false,
      })
      canvas.add(g)

      return g;

    }

    function makeCircle(left, top, color, id, num, has_ball, playerRadius) {
        var ball = null;
        var text = new fabric.Text(num, {
          id: id,
          left: left + playerRadius + 2,
          top: top + playerRadius + 2,
          fontSize: 14,
          fill: 'white',
          originX: 'center',
          originY: 'center',
          hasBorders: false,
          hasControls: false,
          selectable: false,
          evented: false,
          fontFamily: 'Helvetica',
        });

        if(has_ball){
          ball = makeBasketball(top, left, playerRadius)
        }
        var c = new fabric.PlayerCircle({
          id: id,
          left: left,
          top: top,
          strokeWidth: 3,
          radius: playerRadius,
          fill: color,
          stroke: color,
          padding: 10,
          color: color,
          hasBorders: false,
          hasControls: false,
          toAnchorPoint: new fabric.Point(left + playerRadius, top + playerRadius),
          anchorable: true,
          added: true,
          text: text,
          has_ball: has_ball,
          ball: ball,
          objectCaching: true,
        });

        
        canvas.add(c);
        canvas.add(text);

        c.moveTo(1000);
        text.moveTo(1001);
      }

    /******************************************************** <CIRCLE/> ***************************************************************/


    /*********************************************************************************************************************************/
    /**************************************************** <DRAWING OBJECTS/> **********************************************************/
    /*********************************************************************************************************************************/

</script>     -->